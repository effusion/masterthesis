\chapter{Entwurfsentscheidungen}

\section{Teillösungen}

Die folgenden Lösungs wurden für die Teilprobleme erarbeitet. Für die entgültige Architektur wurde nur eine Version verwendet.

\subsection{Schnittstellen Versionierung}

Die Versionierung der Schnittstelle zwischen der Webseite und dem Server muss sichergestellt werde. Da bei der kontinuierlichen Ausrollung von Software meistens mehrere Versionen im laufenden Betrieb sind, muss ein Weg gefunden werden dies auf einfache Weise zu erreichen ohne für den Entwickler zuviel Aufwand zu generieren.

\subsubsection{Versionierung mittels Pfad}

Sollte es nötig sein eine neue Version der \Gls{REST} Schnittstelle zu veröffentliche, kann dies über Versionsnummer im Pfad erreicht werden. 
\newline
\newline
\textbf{Vorteile}
\begin{itemize}
	\item Schnittstellenversionen sind durch den Pfad klar getrennt.
\end{itemize}
\textbf{Nachteile}
\begin{itemize}
	\item Für jede neue Version muss eine neuer Endpoint inklusive URI definiert werden welche der Client kennen muss.
	\item Domänenmodelle liegen unterumständen in mehreren Versionen vor.
	\item Verhältnismässig viel Aufwand für den Nutzen.
\end{itemize}

\subsubsection{Versionierung mittels Content-Negotiation}

Mittels Accept-Header ist es möglich auf einem Endpoint zu definieren welche Version der Resource er akzeptiert.
\newline
\newline
\textbf{Vorteile}
\begin{itemize}
	\item Es gibt nicht mehrere Pfade nach aussen sondern nur einer.
	\item Es können auch kleinere Änderungen gemacht werden ohne die Kompatibilität zu brechen.
\end{itemize}
\textbf{Nachteile}
\begin{itemize}
	\item Auf Serverseite ist trotzdem ein Routing notwending in Form einer neuen Methode falls es sich um eine inkompatible Änderung handelt.
	\item Domänenmodelle liegen unterumständen in mehreren Versionen vor.
	\item Verhältnismässig viel Aufwand für den Nutzen.
\end{itemize}

\subsubsection{Versionierung mittels GraphQL}

Anstelle der klassischen Ansätze der Versionierung über Pfade und Content-Negotiation, gibt es mit GraphQL eine Libary welche diese Probleme anders angeht. Anstelle einer Versionierung können die Attribute mittels einer Abfragesprache vom Server angefordert werden. Dadurch benötigt es auf Serverseite nur noch einen Endpoint.
\newline
\newline
\textbf{Vorteile}
\begin{itemize}
	\item Keine wirkliche Versionierung nötig. Alte Felder können mit deprecated gekennzeichnet werden und nach der kompletten Ausrollung entfernt werden.
	\item Aufwand einiges geringer als bei der Variante mit Pfaden und Content-Negotiation.
\end{itemize}
\textbf{Nachteile}
\begin{itemize}
	\item Der Web Client braucht eine Anpassungen seiner Afrufe an den Server.
\end{itemize}
\textbf{Risiken}
\begin{itemize}
	\item Im Rahmen eines neuen Projekts wurde ein Proof of Concept gemacht allerdings sind noch keine wirklichen Erfahrungen vorhanden.
\end{itemize}

\subsection{Kommunikationsentkopplung}

Durch die geänderten Anforderungen bezüglich Ausrollung der Software ist ein unterbruch zwischen Server und der Business Process Engine unausweichlich. Damit keine Anfragen der Benutzer verloren gehen müssen die Nachrichten entweder gespeichert werden oder es brauch eine Asynchrone Kommunikation. Aktuell werden zwischen dem Server und der \Gls{BPM} Engine REST Call mittels Hystrix abgesetzt.

\subsubsection{Message Queue mit JMS}

Entkopplung kann generell über Messaging erreicht werden welches in der Java Welt mittels dem Java Messaging Service erreicht werden kann. Da an den Benutzer keine Anwort geschickt werden muss,
braucht es nicht unbedingt eine Antwort. Die Zustellung der Nachricht muss jedoch sichergestellt werden. Des Weiteren müssen die Nachrichten dürfen die Nachrichten bei einem Kommunikationsunterbruch nicht verloren gehen.
\newline
\newline
\textbf{Vorteile}
\begin{itemize}
	\item Gute Unterstützung durch das Spring Framework.
	\item Bekanntes Integrationsmuster.
	\item Inhalt der Nachrichten frei wählbar.
\end{itemize}
\textbf{Nachteile}
\begin{itemize}
	\item Umbau der Schnittstelle zwischen Server und BPM Engine.
	\item Messaging Infrastruktur ist nicht vorhanden respektive nicht Verfügbar in der Zone. Diese wäre zusätzlich ein weitere Single Point of Failure.
	\item Messaging Infrastruktur ist für den Use Case überdimensioniert.
\end{itemize}
\textbf{Risiken}
\begin{itemize}
	\item Nicht sicher ob eine solche Middleware überhaupt verwendet werden darf respektive ob Know-how vorhanden ist.
\end{itemize}

Alternative könnte anstelle eine Messaging System auch eine Message Bridge verwendet werden. Hierzu verbindet sich der Server direkt auf die Queue welche sich auf der BPM Engine befindet.

\subsubsection{Message Queue mit Kafka}

Eine weitere Möglichkeit wäre das Versenden von Nachrichten über Kafka\footnote{https://kafka.apache.org}. Entstanden bei grossen Internet Dienstleistern wie Linkedin für welche JMS nicht praktikabel war Aufgrund der Perfomanz(verifizieren). Kafka ist ein verteiltes Messaging System welches auf durchsatz optimiert ist. Für die Zustellung der Nachrichten verwendet Kafka einen sogenannten Nimbus welche die Zustellung an den Empfänger übernimmt.
\newline
\newline
\textbf{Vorteile}
\begin{itemize}
	\item Unterstützung durch das Spring Framework.
	\item Bekanntes Integrationsmuster.
	\item Inhalt der Nachrichten frei wählbar.
	\item Braucht keine zentrale Infrastruktur und kann selber aufgebaut werden.
\end{itemize}
\textbf{Nachteile}
\begin{itemize}
	\item Umbau der Schnittstelle zwischen Server und BPM Engine.
	\item Infrastruktur muss selber administriert werden.
	\item Für den Use Case überdimensioniert da gar nie soviele Nachrichten über das System verschickt werden.
\end{itemize}
\textbf{Risiken}
\begin{itemize}
	\item Know-how zu Kafka hinsichlicht Betrieb und Verwendung nicht vorhanden.
\end{itemize}

\subsubsection{Message Queue mit Key-Value Store}

Anstelle eines Messaging Systems, bietet sich die Möglichkeit an Redis als Message queue zu verwenden. Würde Redis gleichzeitig als Datenspeicher verwendet könntem hier Synergien genutz werden.
\newline
\newline
\textbf{Vorteile}
\begin{itemize}
	\item Bietet asynchrones Messaging über eine eingebaute Queue Funktionalität.
	\item Schemalos und wodurch Nachrichten eifach gespeichert werden können.
	\item Eliminiert die Probleme der Speicherung und Asynchronität gleichzeitig.
\end{itemize}
\textbf{Nachteile}
\begin{itemize}
	\item Umbau der Schnittstelle zwischen Server und BPM Engine.
\end{itemize}
\textbf{Risiken}
\begin{itemize}
	\item Java Connection für Master/Slave Konfiguration befindet sich noch in der Entwicklung resp. muss selber gemacht werden. Gleiches gilt für die Clusterfunktionalität.
\end{itemize}

\subsubsection{Spring Rest}

Aktuell werden die Requests an die BPM Engine mittels Hystrix\footnote{https://github.com/Netflix/Hystrix} und REST abgeschickt. Die Request werden dabei gleich zur Workflow Engine geschickt oder im Fehlerfall als JSON in die Datenbank gespeichert. Mit einem Scheduler werden dann später die nicht gesendeten Request nochmals verschickt. Die Datenbank hat deshalb eine Queue ähnliche Funktion.
\newline
\newline
\textbf{Vorteile}
\begin{itemize}
	\item Nur geringfügige Anpassungen an der Schnittstelle auf Serverseite.
\end{itemize}
\textbf{Nachteile}
\begin{itemize}
	\item Keine wirkliche Entkopplung der Dienste.
\end{itemize}
\textbf{Risiken}

\subsection{Datenspeicherung}

Aktuell wir eine MySQL als Datenbank verwendet welche zur Zeit nur Requests speichert und kleinere Abfragen ausführt.. Die neuen Anforderungen an die Datenbank bezüglich Continuous Deployment sind:
\begin{itemize}
	\item Replikation wird unterstützt und kann auf dem Client konfiguriert werden.
	\item Es ist möglich mit mehreren Applikations Version auf die gleiche Datenbank zuzugreifen.
\end{itemize}
Vorallem der Zweite Punkt hat hohe bedeutung da bei Continuous Delivery bei der Installation der Software immer mindest zwei verschiedene Versionen der Applikation gleichzeitig auf den Datenspeicher zugreifen. Die Anwendung verwendet bereits Spring Data als Persitzenz-Bibliothek welche für alle aufgeführten Lösungsvarianten entsprechende Erweiterungen besitzt.

Folgend die einzlenen Teillösungen für die Datenspeicherung.

\subsubsection{Relationale Datenbank mit Oracle}

Oracle ist bei vielen Firmen die Standart Software für Datenbank. Sie bietet sämtliche features welche im Bereich von Finanzdienstleistern benötigt werden hat aber auch ihren Preis. Oralce basiert auf klassischen relationalen Prinzipien und setzt auf hohe Datenkonsitzenz.
\newline
\newline
\textbf{Vorteile}
\begin{itemize}
	\item Sehr gutes und verbreitetes Know-how bezüglich Betrieb, erstellen von Anfragen, optimierung usw.
	\item Baisert auf \Gls{ACID} und gewährteistet deshalb die Datenkonsistenz.
	\item Bietet Enterprise fähige Replikationsmechanismen.
\end{itemize}
\textbf{Nachteile}
\begin{itemize}
	\item Daten werden nach einem Schema abgelegt welches nicht mit verschiedenen Versionen umgehen kann.
	\item Versionierung muss selber mittels Triggern und Migrationsskripten gemacht werden.	
\end{itemize}
\textbf{Risiken}
\begin{itemize}
	\item Oracle darf aus Lizenzgründen nur auf pysischen Maschinen installiert werden.
	\item High Availability Mode welcher zu Verfügung steht nicht klar.
\end{itemize}

\subsubsection{Relationale Datenbank mit MySQL}

MySQL wird wie bereits aktuell verwendet. Es bietet die klassischen Funktionen einer relationalen Datenbank. MySQL wird meistens verwendet wenn Oracle zu teuer ist resp. die Anforderungen an die Datenhaltung nicht so hoch sind.
\newline
\newline
\textbf{Vorteile}
\begin{itemize}
	\item Wird bereits eingesetzt.
	\item Baisert auf \gls{ACID} und gewährteistet deshalb die Datenkonsistenz.
\end{itemize}
\textbf{Nachteile}
\begin{itemize}
	\item Daten werden nach einem Schema abgelegt welches nicht mit verschiedenen Versionen umgehen kann.
	\item Versionierung muss selber mittels Triggern und Migrationsskripten gemacht werden.
\end{itemize}
\textbf{Risiken}
\begin{itemize}
	\item Umschaltung von Master auf Slave muss aufwendig manuell durgeführt werden.
\end{itemize}

\subsubsection{Dokumentenbasierte Datenbank}

Als alternative zu einer relationalen Datenbank, kann eine dokumentenbasierte wie zum Beispiel MongoDB\footnote{https://www.mongodb.com} verwendet werden. Die Datenbank gehöhrt zu Familie der \Gls{NoSQL} Speicher und ist deshalb Schemalos. Sie ist durch Ihre Natur mit Dokumenten zu Arbeite trotzdem stuckweit strukturiert. 
\newline
\newline
\textbf{Vorteile}
\begin{itemize}
	\item Kein Schema vorhanden weshalb die Daten in verschiedenen Versionen gespeichert werden können.
	\item Hirarchische struktur von JSON passt gut zur Natur der Datenbank.
	\item Bietet Datenreplikation mittels Master/Slave und Replica Sets.
\end{itemize}
\textbf{Nachteile}
\begin{itemize}
	\item Anpassung des Persistzenslayers nötig.
\end{itemize}
\textbf{Risiken}
\begin{itemize}
	\item Keine Erfahrung mit der Datenbank (Verwendung, Betrieb, Abfragen).
\end{itemize}

\subsubsection{Key-Value Datenbank}

Eine weitere Möglichkeit ist ein Key-Value Store für die Speicherung zu verwendent. Es handelt sich Dabei um eine NoSQL Datenbank welche wie eine HashMap Funktioniert. Daten können schnell gespeichert und mit dem Key wieder geholt werden. Gewisse Abfrage Möglichkeiten sind ebenfalls gegeben. Des Weiteren ist die Datenbank Schema was eslaubt verschiedenste Strukturen zu speichern. In diesem konkreten Fall wird Redis\footnote{https://redis.io} als Lösung in betracht gezogen. \newline
\newline
\textbf{Vorteile}
\begin{itemize}
	\item Bereits in Betrieb und daher vorhandenes Know-how
	\item Kein Schema vorhanden weshalb die Daten in verschiedenen Versionen gespeichert werden können.
	\item Bietet High Availablity wie Clustering und Sentinel.
	\item Könnte im gleichen Zuge auf für die Queue verwendet werden.	
\end{itemize}
\textbf{Nachteile}
\begin{itemize}
	\item Abfrage Möglichkeiten beschränkt.
	\item Anpassung des Persistzenslayers nötig.
\end{itemize}
\textbf{Risiken}
\begin{itemize}
	\item Keine Erfahrung mit den Clusterfuntkionalitäten.
\end{itemize}

\subsection{Konfigurations Management}

Soll die Applikation kontinuierlich ausgerollt werden, sind manuelle Anpassungen an Konfigurationsdateinen hinderlich. Ob das nun Propert files, Dockerfiles oder andere Dateinen sind. Gewisse Änderungen erfordern einen neustart von Systemen falls für den Container eine neue Version gebaut wird. Für andere wäre es wünscheswert gäbe es einen Weg die Konfiguration ohne einen anzupassen. Hierzu einige Beispiele:\newline
\begin{itemize}
	\item Hostnamen, Ports
	\item Usernamem, Passwörter, Email-Adressen
	\item Datenbank Konfigurationen
	\item Dateien welche Zertifikate beinhalten.
\end{itemize}

Auf Testumgebungen ist dies meistens kein Problem da entsprechene Konfigurationen mitabgelegt sind. Die Probleme treten aktuell hauptsächlich für Produktive Systeme bei welchen keine Passwörter mit eingegeckt werden können.

\subsubsection{Docker Compose, Swarm}

Aktuell ist die Konfiguration der \Gls{Container} in einem Properties gespeichert. Mit Compose\footnote{https://docs.docker.com/compose/} werden die Anhängigkeiten zwischen den Container definiert und die Konfiguration in den Container gelinkt.\newline
\newline
\textbf{Vorteile}
\begin{itemize}
	\item Wird aktuell bereits eingesetzt.
	\item Konfigurationen der Container können von aussen injziert werden.
\end{itemize}
\textbf{Nachteile}
\begin{itemize}
	\item Konfigurationsänderungen an der Applikation führen zu einem neustart.
\end{itemize}
\textbf{Risiken}
\begin{itemize}
	\item Nicht kombatibel mit Kubernetes welche bei Openshift\footnote{https://www.openshift.org: Plattform welche das Ausrollen von Containers im Sinne einer Cloud Umgebung ermöglicht.}  verwendet wird. Die Plattfrom ist im Aufbau und wird die zukünfige Plattform.
\end{itemize}

\subsubsection{Kubernetes}

Kubernetes ist ein andere Framework\footnote{http://kubernetes.io: Wurde von Google Entwickelt und beschränkt sich nicht nur auf Docker Container.} für die Konfiguration von Containern und deren Abhängigkeiten. Kubernetes verfolgt eine andere Philosophie und ist aus diesem Grund nicht kompatible mit der Docker eingenen API.
\newline
\newline
\textbf{Vorteile}
\begin{itemize}
	\item Ist die Basis von Openshift welches als Standart Plattform für Container etabliert werden soll und daher von strategische Bedeutung.
\end{itemize}
\textbf{Nachteile}
\begin{itemize}
	\item Anpassungen an der Orchestration der Container.
\end{itemize}
\textbf{Risiken}
\begin{itemize}
	\item Plattform ist noch nicht wirklich in Betrieb sonder nur zu Testzwecken installiert.
	\item Kein Know-how zu Kubernetes vorhanden.
\end{itemize}
\subsubsection{Spring Cloud Config}

Spring Cloud Config\footnote{https://cloud.spring.io/spring-cloud-config/} bieted die Möglichkeit Konfigurationen währed dem laufend Betrieb zu ändern. Dadurch muss ein Applikation/Container bei Konfigurationänderungen nicht neu gestartet werden. Änderungen am Deployment des Containers selber kann die Library jedoch nicht ändern.\newline
\newline
\textbf{Vorteile}
\begin{itemize}
	\item Integriert sich gut mit dem Spring Framework
	\item Konfigurationen können während dem laufenden Betreib geändert werden.
	\item Da der Server zustandslos ist, kann Hochverfügbarkeit einfach erreicht weden.
\end{itemize}
\textbf{Nachteile}
\begin{itemize}
	\item Benötigt einen neuen Config Server und Anpassungen der Applikation.
	\item Kann keine Änderungen an der Containerkonfiguration vornehmen.
\end{itemize}
\textbf{Risiken}
\begin{itemize}
	\item Erhöht die Komplexität des Systems weiter.
\end{itemize}

\subsubsection{Saltstack}

Saltstack ist ein Konfigurationmanagement mit welchem sich Server und deren Applikationen auf verschiedenen physischen oder virutell Rechner konfigurieren lassen. Zusätzlich können die Server gruppiert werden um logische Einheiten wie Entwicklung, Test, Produktion zu modellieren.\newline
\newline
\textbf{Vorteile}
\begin{itemize}
	\item Erlaub das Schreiben von Konfugrationsscripty mittels Python.
	\item Benötigt kein grosses Setup auf dem Client.
\end{itemize}
\textbf{Nachteile}
\begin{itemize}
	\item Kolidiert mit dem Ansatz Containern da diese unveränderbar sind und Änderungen deshalb von aussen injziert werden müssen.
	\item Kein Know-how vorhanden.
\end{itemize}
\textbf{Risiken}
\begin{itemize}
	\item Wird durch den Einsatz von OpenShift für Container wahrscheinlich obsolet.
\end{itemize}

\subsection{Deployment Pipeline}

Hier fehlen noch informationen resp. Anforderungen. Was ist mit der Sicherheit?

\section{Bewertungskriterienkatalog}

Mit Hilfe der Bewertungskriteren sollen die einzelne Teillösungen bewertet werden um daraus Lösungsvarianten zu definieren. Für die Varianten oder Teillösungen werden dann Prototypen entwickelt um deren Umsetzbarkeit zu verfizieren.

\section{Lösungsvarianten}

Mithilfe der Teillösungen wurden folgende Lösungsvariante erstellt. 



