\newcounter{bk} \stepcounter{bk} %Bewertungskriterien counter

\chapter{Entwurfsentscheidungen}

\section{Teillösungen}

Um eine Architektur zu entwickeln, müssen zuerst Lösungen für die Teilprobleme erarbeitet werden. in den folgenden Kapiteln sind mehrere Varianten mit ihren Vor-, Nachteilen und Risiken aufgeführt. Diese Ansätze sind nur oberflächlich erforscht worden um den Lösungsraum möglichst gross zu machen. Diese Ansätze werden dann bewertet mit welchen Lösungsvarianten zusammenstellen werden. Diese Varianten wiederum gelten als Basis für die Prototypen um zu verifizieren das die wichigten Punkte eingehalten werden können. Erst danach wird die Architektur definiert.

\subsection{Schnittstellen Versionierung}

Die Versionierung der Schnittstelle zwischen der Webseite und dem Server muss sichergestellt werde. Da bei der kontinuierlichen Ausrollung von Software meistens mehrere Versionen im laufenden Betrieb sind, muss ein Weg gefunden werden dies auf einfache Weise zu erreichen ohne für den Entwickler zuviel Aufwand zu generieren.

\subsubsection{Versionierung mittels Pfad}

Sollte es nötig sein eine neue Version der \Gls{REST} Schnittstelle zu veröffentliche, kann dies über Versionsnummer im Pfad erreicht werden. Hierfür wird die URL für den Rest-Endpoint mit einer Versionsnummer versehen z.B 'servername/meon/api/v2/'.
\newline
\newline
\textbf{Vorteile}
\begin{itemize}
	\item Schnittstellenversionen sind durch den Pfad klar getrennt.
\end{itemize}
\textbf{Nachteile}
\begin{itemize}
	\item Für jede neue Version muss eine neuer Endpoint inklusive URI definiert werden welche der Client kennen muss.
	\item Domänenmodelle liegen unterumständen in mehreren Versionen vor.
	\item Verhältnismässig viel Aufwand für den Nutzen.
\end{itemize}

\subsubsection{Versionierung mittels Content-Negotiation}

Mittels Accept-Header ist es möglich auf einem Endpoint zu definieren welche Version der Resource er akzeptiert. Dadurch kann auf Rest-Controller Ebene eine Art Routing gemacht werden welche Methode die Anfrage entgegen nimmt und so die Versionierung sichergestellt werden.
\newline
\newline
\textbf{Vorteile}
\begin{itemize}
	\item Es gibt nicht mehrere Pfade nach aussen sondern nur einer.
	\item Es können auch kleinere Änderungen gemacht werden ohne die Kompatibilität zu brechen.
\end{itemize}
\textbf{Nachteile}
\begin{itemize}
	\item Auf Serverseite ist trotzdem ein Routing notwending in Form einer neuen Methode falls es sich um eine inkompatible Änderung handelt.
	\item Domänenmodelle liegen unterumständen in mehreren Versionen vor.
	\item Verhältnismässig viel Aufwand für den Nutzen.
\end{itemize}

\subsubsection{Versionierung mittels GraphQL}

Anstelle der klassischen Ansätze der Versionierung über Pfade und Content-Negotiation, gibt es mit GraphQL eine Libary welche diese Probleme anders angeht. Anstelle einer Versionierung können die Attribute mittels einer Abfragesprache vom Server angefordert werden. Dadurch benötigt es auf Serverseite nur noch einen Endpoint.
\newline
\newline
\textbf{Vorteile}
\begin{itemize}
	\item Keine wirkliche Versionierung nötig. Alte Felder können mit deprecated gekennzeichnet werden und nach der kompletten Ausrollung entfernt werden.
	\item Aufwand einiges geringer als bei der Variante mit Pfaden und Content-Negotiation.
\end{itemize}
\textbf{Nachteile}
\begin{itemize}
	\item Der Web Client braucht eine Anpassungen seiner Afrufe an den Server.
\end{itemize}
\textbf{Risiken}
\begin{itemize}
	\item Im Rahmen eines neuen Projekts wurde ein Proof of Concept gemacht allerdings sind noch keine wirklichen Erfahrungen vorhanden.
\end{itemize}

\subsection{Kommunikationsentkopplung}

Durch die geänderten Anforderungen bezüglich Ausrollung der Software ist ein unterbruch zwischen Server und der Business Process Engine unausweichlich. Damit keine Anfragen der Benutzer verloren gehen müssen die Nachrichten entweder gespeichert werden oder es brauch eine Asynchrone Kommunikation. Aktuell werden zwischen dem Server und der \Gls{BPM} Engine REST Call mittels Hystrix abgesetzt.

\subsubsection{Message Queue mit JMS}

Entkopplung kann generell über Messaging erreicht werden welches in der Java Welt mittels dem Java Messaging Service erreicht werden kann. Da an den Benutzer keine Anwort geschickt werden muss, braucht es nicht unbedingt eine Antwort. Die Zustellung der Nachricht muss jedoch sichergestellt werden. Des Weiteren müssen die Nachrichten dürfen die Nachrichten bei einem Kommunikationsunterbruch nicht verloren gehen.
\newline
\newline
\textbf{Vorteile}
\begin{itemize}
	\item Gute Unterstützung durch das Spring Framework.
	\item Bekanntes Integrationsmuster.
	\item Inhalt der Nachrichten frei wählbar.
\end{itemize}
\textbf{Nachteile}
\begin{itemize}
	\item Umbau der Schnittstelle zwischen Server und BPM Engine.
	\item Messaging Infrastruktur ist nicht vorhanden respektive nicht Verfügbar in der Zone. Diese wäre zusätzlich ein weitere Single Point of Failure.
	\item Messaging Infrastruktur ist für den Use Case überdimensioniert.
\end{itemize}
\textbf{Risiken}
\begin{itemize}
	\item Nicht sicher ob eine solche Middleware überhaupt verwendet werden darf respektive ob Know-how vorhanden ist.
\end{itemize}

Alternative könnte anstelle eine Messaging System auch eine Message Bridge verwendet werden. Hierzu verbindet sich der Server direkt auf die Queue welche sich auf der BPM Engine befindet.

\subsubsection{Message Queue mit Kafka}

Eine weitere Möglichkeit wäre das Versenden von Nachrichten über Kafka\footnote{https://kafka.apache.org}. Entstanden bei grossen Internet Dienstleistern wie Linkedin für welche JMS nicht praktikabel war Aufgrund der Perfomanz(verifizieren). Kafka ist ein verteiltes Messaging System welches auf durchsatz optimiert ist. Für die Zustellung der Nachrichten verwendet Kafka einen sogenannten Nimbus welche die Zustellung an den Empfänger übernimmt.
\newline
\newline
\textbf{Vorteile}
\begin{itemize}
	\item Unterstützung durch das Spring Framework.
	\item Bekanntes Integrationsmuster.
	\item Inhalt der Nachrichten frei wählbar.
	\item Braucht keine zentrale Infrastruktur und kann selber aufgebaut werden.
\end{itemize}
\textbf{Nachteile}
\begin{itemize}
	\item Umbau der Schnittstelle zwischen Server und BPM Engine.
	\item Infrastruktur muss selber administriert werden.
	\item Für den Use Case überdimensioniert da gar nie soviele Nachrichten über das System verschickt werden.
\end{itemize}
\textbf{Risiken}
\begin{itemize}
	\item Know-how zu Kafka hinsichlicht Betrieb und Verwendung nicht vorhanden.
\end{itemize}

\subsubsection{Message Queue mit Key-Value Store}

Anstelle eines Messaging Systems, bietet sich die Möglichkeit an Redis als Message queue zu verwenden. Würde Redis gleichzeitig als Datenspeicher verwendet könnten hier Synergien genutz werden. 
\newline
\newline
\textbf{Vorteile}
\begin{itemize}
	\item Bietet asynchrones Messaging über eine eingebaute Queue Funktionalität.
	\item Schemalos und wodurch Nachrichten eifach gespeichert werden können.
	\item Eliminiert die Probleme der Speicherung und Asynchronität gleichzeitig.
\end{itemize}
\textbf{Nachteile}
\begin{itemize}
	\item Umbau der Schnittstelle zwischen Server und BPM Engine.
\end{itemize}
\textbf{Risiken}
\begin{itemize}
	\item Java Connection für Master/Slave Konfiguration befindet sich noch in der Entwicklung resp. muss selber gemacht werden. Gleiches gilt für die Clusterfunktionalität.
\end{itemize}

\subsubsection{Spring Rest}

Aktuell werden die Requests an die BPM Engine mittels Hystrix\footnote{https://github.com/Netflix/Hystrix} und REST abgeschickt. Die Request werden dabei gleich zur Workflow Engine geschickt oder im Fehlerfall als JSON in die Datenbank gespeichert. Mit einem Scheduler werden dann später die nicht gesendeten Request nochmals verschickt. Die Datenbank hat deshalb eine Queue ähnliche Funktion.
\newline
\newline
\textbf{Vorteile}
\begin{itemize}
	\item Nur geringfügige Anpassungen an der Schnittstelle auf Serverseite.
\end{itemize}
\textbf{Nachteile}
\begin{itemize}
	\item Keine wirkliche Entkopplung der Dienste.
\end{itemize}
\textbf{Risiken}

\subsection{Datenspeicherung}

Aktuell wir eine MySQL als Datenbank verwendet welche zur Zeit nur Requests speichert und kleinere Abfragen ausführt.. Die neuen Anforderungen an die Datenbank bezüglich Continuous Deployment sind:
\begin{itemize}
	\item Replikation wird unterstützt und kann auf dem Client konfiguriert werden.
	\item Es ist möglich mit mehreren Applikations Version auf die gleiche Datenbank zuzugreifen.
\end{itemize}
Vorallem der Zweite Punkt hat hohe bedeutung da bei Continuous Delivery bei der Installation der Software immer mindest zwei verschiedene Versionen der Applikation gleichzeitig auf den Datenspeicher zugreifen. Die Anwendung verwendet bereits Spring Data als Persitzenz-Bibliothek welche für alle aufgeführten Lösungsvarianten entsprechende Erweiterungen besitzt. Der Serverteil hält aktuell nur sechs Tabellen da die ganze Verarbeitung der Daten auf der Workflow-Engine gemacht wird.

\subsubsection{Relationale Datenbank mit Oracle}

Oracle ist bei vielen Firmen die Standart Software für Datenbank. Sie bietet sämtliche Features welche im Bereich von Finanzdienstleistern benötigt werden hat aber auch ihren Preis. Oralce basiert auf klassischen relationalen Prinzipien und setzt auf hohe Datenkonsitzenz. Für die Replikation bietet Oracle diverse Mechanismen und Setup welche unterschiedliche Kosten haben.
\newline
\newline
\textbf{Vorteile}
\begin{itemize}
	\item Sehr gutes und verbreitetes Know-how bezüglich Betrieb, erstellen von Anfragen, optimierung usw.
	\item Baisert auf \Gls{ACID} und gewährteistet deshalb die Datenkonsistenz.
	\item Bietet Enterprise fähige Replikationsmechanismen.
\end{itemize}
\textbf{Nachteile}
\begin{itemize}
	\item Daten werden nach einem Schema abgelegt welches nicht mit verschiedenen Versionen umgehen kann.
	\item Versionierung muss selber mittels Triggern und Migrationsskripten gemacht werden.	
	\item Für die aktuell sechs Tabellen ein grosser Kostenpunkt. 
\end{itemize}
\textbf{Risiken}
\begin{itemize}
	\item Oracle darf aus Lizenzgründen nur auf pysischen Maschinen installiert werden.
	\item High Availability Mode welcher zu Verfügung steht nicht klar.
\end{itemize}

\subsubsection{Relationale Datenbank mit MySQL}

MySQL wird wie bereits aktuell verwendet. Es bietet die klassischen Funktionen einer relationalen Datenbank. MySQL wird meistens verwendet wenn Oracle zu teuer ist resp. die Anforderungen an die Datenhaltung nicht so hoch sind. MySQL bietet akutell auch Replikation mittels Master-Slave an und Tools für eine automatische Umschaltung
\newline
\newline
\textbf{Vorteile}
\begin{itemize}
	\item Wird bereits eingesetzt.
	\item Baisert auf \gls{ACID} und gewährteistet deshalb die Datenkonsistenz.
\end{itemize}
\textbf{Nachteile}
\begin{itemize}
	\item Daten werden nach einem Schema abgelegt welches nicht mit verschiedenen Versionen umgehen kann.
	\item Versionierung muss selber mittels Triggern und Migrationsskripten gemacht werden.
\end{itemize}
\textbf{Risiken}
\begin{itemize}
	\item Kein Know-How mit MySQL Cluster oder dem Mysqlfailover Util.
\end{itemize}

\subsubsection{Dokumentenbasierte Datenbank}

Als alternative zu einer relationalen Datenbank, kann eine dokumentenbasierte wie zum Beispiel MongoDB\footnote{https://www.mongodb.com} verwendet werden. Die Datenbank gehöhrt zu Familie der \Gls{NoSQL} Speicher und ist deshalb Schemalos. Von den \gls{NoSQL} Datenbanken besitzen die Dokumente basierte die grösste Struktur im sinn der Datenspeicherung.
\newline
\newline
\textbf{Vorteile}
\begin{itemize}
	\item Kein Schema vorhanden weshalb die Daten in verschiedenen Versionen gespeichert werden können.
	\item Hirarchische struktur von JSON passt gut zur Natur der Datenbank.
	\item Bietet Datenreplikation mittels Master/Slave und Replica Sets.
\end{itemize}
\textbf{Nachteile}
\begin{itemize}
	\item Anpassung des Persistzenslayers nötig.
\end{itemize}
\textbf{Risiken}
\begin{itemize}
	\item Keine Erfahrung mit der Datenbank (Verwendung, Betrieb, Abfragen).
\end{itemize}

\subsubsection{Key-Value Datenbank}

Eine weitere Möglichkeit ist ein Key-Value Store für die Speicherung zu verwendent. Es handelt sich Dabei um eine NoSQL Datenbank welche wie eine HashMap Funktioniert. Daten können schnell gespeichert und mit dem Key wieder geholt werden. Gewisse Abfrage Möglichkeiten sind ebenfalls gegeben. Des Weiteren ist die Datenbank Schema was eslaubt verschiedenste Strukturen zu speichern. In diesem konkreten Fall wird Redis\footnote{https://redis.io} als Lösung in betracht gezogen. \newline
\newline
\textbf{Vorteile}
\begin{itemize}
	\item Bereits in Betrieb und daher vorhandenes Know-how
	\item Kein Schema vorhanden weshalb die Daten in verschiedenen Versionen gespeichert werden können.
	\item Bietet High Availablity wie Clustering und Sentinel.
	\item Könnte im gleichen Zuge auf für die Queue verwendet werden.	
\end{itemize}
\textbf{Nachteile}
\begin{itemize}
	\item Abfrage Möglichkeiten beschränkt.
	\item Anpassung des Persistzenslayers nötig.
\end{itemize}
\textbf{Risiken}
\begin{itemize}
	\item Keine Erfahrung mit den Clusterfuntkionalitäten.
\end{itemize}

\subsection{Konfigurations Management}

Soll die Applikation kontinuierlich ausgerollt werden, sind manuelle Anpassungen an Konfigurationsdateinen hinderlich. Ob das nun Propert files, Dockerfiles oder andere Dateinen sind. Gewisse Änderungen erfordern einen neustart von Systemen falls für den Container eine neue Version gebaut wird. Für andere wäre es wünscheswert gäbe es einen Weg die Konfiguration ohne einen anzupassen. Hierzu einige Beispiele:\newline
\begin{itemize}
	\item Hostnamen, Ports
	\item Usernamem, Passwörter, Email-Adressen
	\item Datenbank Konfigurationen
	\item Dateien welche Zertifikate beinhalten.
\end{itemize}

Auf Testumgebungen ist dies meistens kein Problem da entsprechene Konfigurationen mitabgelegt sind. Die Probleme treten aktuell hauptsächlich für Produktive Systeme bei welchen keine Passwörter mit eingegeckt werden können.

\subsubsection{Docker Compose, Swarm}

Aktuell ist die Konfiguration der \Gls{Container} in einem Properties gespeichert. Mit Compose\footnote{https://docs.docker.com/compose/} werden die Anhängigkeiten zwischen den Container definiert und die Konfiguration in den Container gelinkt.\newline
\newline
\textbf{Vorteile}
\begin{itemize}
	\item Wird aktuell bereits eingesetzt.
	\item Konfigurationen der Container können von aussen injziert werden.
\end{itemize}
\textbf{Nachteile}
\begin{itemize}
	\item Konfigurationsänderungen an der Applikation führen zu einem neustart.
\end{itemize}
\textbf{Risiken}
\begin{itemize}
	\item Nicht kombatibel mit Kubernetes welche bei Openshift\footnote{https://www.openshift.org: Plattform welche das Ausrollen von Containers im Sinne einer Cloud Umgebung ermöglicht.}  verwendet wird. Die Plattfrom ist im Aufbau und wird die zukünfige Plattform.
\end{itemize}

\subsubsection{Kubernetes}

Kubernetes ist ein andere Framework\footnote{http://kubernetes.io: Wurde von Google Entwickelt und beschränkt sich nicht nur auf Docker Container.} für die Konfiguration von Containern und deren Abhängigkeiten. Kubernetes verfolgt eine andere Philosophie und ist aus diesem Grund nicht kompatible mit der Docker eingenen API.
\newline
\newline
\textbf{Vorteile}
\begin{itemize}
	\item Ist die Basis von Openshift welches als Standart Plattform für Container etabliert werden soll und daher von strategische Bedeutung.
\end{itemize}
\textbf{Nachteile}
\begin{itemize}
	\item Anpassungen an der Orchestration der Container.
\end{itemize}
\textbf{Risiken}
\begin{itemize}
	\item Plattform ist noch nicht wirklich in Betrieb sonder nur zu Testzwecken installiert.
	\item Kein Know-how zu Kubernetes vorhanden.
\end{itemize}

\subsubsection{Spring Cloud Config}

Spring Cloud Config\footnote{https://cloud.spring.io/spring-cloud-config/} bieted die Möglichkeit Konfigurationen währed dem laufend Betrieb zu ändern. Dadurch muss ein Applikation/Container bei Konfigurationänderungen nicht neu gestartet werden. Änderungen am Deployment des Containers selber kann die Library jedoch nicht ändern.\newline
\newline
\textbf{Vorteile}
\begin{itemize}
	\item Integriert sich gut mit dem Spring Framework
	\item Konfigurationen können während dem laufenden Betreib geändert werden.
	\item Da der Server zustandslos ist, kann Hochverfügbarkeit einfach erreicht weden.
\end{itemize}
\textbf{Nachteile}
\begin{itemize}
	\item Benötigt einen neuen Config Server und Anpassungen der Applikation.
	\item Kann keine Änderungen an der Containerkonfiguration vornehmen.
\end{itemize}
\textbf{Risiken}
\begin{itemize}
	\item Erhöht die Komplexität des Systems weiter.
\end{itemize}

\subsubsection{Saltstack}

Saltstack ist ein Konfigurationmanagement mit welchem sich Server und deren Applikationen auf verschiedenen physischen oder virutell Rechner konfigurieren lassen. Zusätzlich können die Server gruppiert werden um logische Einheiten wie Entwicklung, Test, Produktion zu modellieren.\newline
\newline
\textbf{Vorteile}
\begin{itemize}
	\item Erlaub das Schreiben von Konfugrationsscripty mittels Python.
	\item Benötigt kein grosses Setup auf dem Client.
\end{itemize}
\textbf{Nachteile}
\begin{itemize}
	\item Kolidiert mit dem Ansatz Containern da diese unveränderbar sind und Änderungen deshalb von aussen injziert werden müssen.
	\item Kein Know-how vorhanden.
\end{itemize}
\textbf{Risiken}
\begin{itemize}
	\item Wird durch den Einsatz von OpenShift für Container wahrscheinlich obsolet.
\end{itemize}

\subsection{Deployment Pipeline}

Damit die Applikation nach einem Comit eines Entwicklers gebaut, getestet und schliesslich installiert wird braucht es eine Deployment Pipeline welche sämtliche Schritte automatisch durchführt. Stand heute gibt es für den 'develop', 'master' eine eigene Pipeline. Zusätzlich hat wird jedes Feature noch separat gebaut. Die Erweiterungen oder Behebungen werden dann mittels Merge in den Master-Branch verschoben wo der produktive Build gebaut wird. 

\subsubsection{Pipeline mit Freigabe für Produktion}

...\newline
\newline
\textbf{Vorteile}
\begin{itemize}
	\item .
\end{itemize}
\textbf{Nachteile}
\begin{itemize}
	\item .
\end{itemize}
\textbf{Risiken}
\begin{itemize}
	\item .
\end{itemize}

\subsubsection{Pipleine ohne Freigabe für Produktion}

...\newline
\newline
\textbf{Vorteile}
\begin{itemize}
	\item .
\end{itemize}
\textbf{Nachteile}
\begin{itemize}
	\item .
\end{itemize}
\textbf{Risiken}
\begin{itemize}
	\item .
\end{itemize}

\section{Bewertungskriterienkatalog}

Mit Hilfe der Bewertungskriteren sollen die einzelne Teillösungen bewertet werden um daraus Lösungsvarianten zu definieren. Für die Varianten oder Teillösungen werden dann Prototypen entwickelt um deren Umsetzbarkeit zu verfizieren. Die Bewertungskriterien mögen sich stellenweise mit den Qualitätszielen überschneiden, betrachten die Lösungen jedoch auf einen anderen Ebene. Nicht alle Kriterien sind auf alle Teillösungen anwendbar und werden in der Matrix später nicht ausgefüllt.\newline
Für die Gewichtung als auch die für die Bewertung wird eine Skala von Eins bis Fünf verwendet mit Eins als schwache Gewichtung/Bewertung und Fünf als starte Gewichtung/Bewertung.

\newgeometry{left=2.5cm, right=2.5cm, bottom=2.5cm, top=2.5cm}
\begin{landscape}
\begin{longtable}{ | p{1.2cm} | p{3cm} | p{8cm} | p{2cm} | p{8cm} | }
		\toprule
		{\textbf{ID}} & {\textbf{Name}} & {\textbf{Beschreibung}} & {\textbf{Gewicht}} & {\textbf{Begründung}}\\
		\midrule 
		BK-\arabic{bk} \stepcounter{bk} & Ausfallsicherheit / Konsistenz & Die Komponente ermöglicht automatische Ausfallsicherheit ohne manuelle interaktion eines Administrators.& 5 & Nicht-funktionale Anforderung an die Architektur. Notwending dabei bei kontinuierlicher Ausrollung keine inkonsistenzen entstehen.\\ \hline
		BK-\arabic{bk} \stepcounter{bk} & Reifegrad & Die Komponente wird akutell von anderen Firmen in produktiven Umgebungen eingesetzt und hat eine ausführliche Dokumentation und Literatur. Für Obensource gilt, dass die Komponente eine entsprechende Community hat und aktive entwickelt wird.  & 4 & Der Einsatz von unreifer Software führt zu Mehraufwand in Fehlerfällen resp. falls Fehler auftreten die lange brauchen bis sie behoben werden.\\ \hline
		BK-\arabic{bk} \stepcounter{bk} & Entkopplungsgrad & Die Komponente erlaubt die asynchrone Kommunikation.& 4 & Nicht-funkionale Anforderung welche wichtig ist damit der Benutzer von einem unterbruch des Dienstes nichts merkt. \\ \hline
		BK-\arabic{bk} \stepcounter{bk} & Skalierbarkeit & Die Komponente lässt sich durch Konfiguration resp. durch bereitstellen eines neuen Containers horizontal skalieren.& 5 & Nicht-funktionale Anforderungan die Architektur. Während der Installation ist immer ein Teil der Applikation nicht erreichbar. Die Skalierbarkeit stellt deshalb sicher, dass in diesem Fall immer genug Resourcen vorhanden sind um die Anfragen zu bearbeiten. \\ \hline
		BK-\arabic{bk} \stepcounter{bk} & Wartbarkeit & Die eingesetzte Komponente ist Wartungsfreundlich und braucht. & 3 & Die Wartung der Software sollte in einem angemessenem Rahmen möglich sein.\\ \hline
		BK-\arabic{bk} \stepcounter{bk} & Lizenzkosten & Die Komponente hat möglichst kleine einmalig und wiederkehrende Kosten. & 3 & Die Kosten sind wichtig jedoch ist im Bereich der Finanzindustrie die Konsistenz höher weit gewichtet.\\ \hline
		BK-\arabic{bk} \stepcounter{bk} & Testbarkeit & Die Komponente läst sich einfach in einer Testumgebung oder für Unittests aufsetzten. &  3 & Die Komponente sollte sich gut testen lassen. Das ein gewisser Aufwand wird jedoch in kauf genommen.\\ \hline
		BK-\arabic{bk} \stepcounter{bk} & Interportabilität & Die Komponente ist technologisch Unabhängig und lässt sich einfach mit anderen integrieren. & 3 & Die Software sollte sich mit den wichtigsten Technologien verwenden lassen. Die Applikation selber ist jedoch spezifsch weshalb dies weniger gewertet wird.\\ \hline
		BK-\arabic{bk} \stepcounter{bk} & Lernkurve & Die Konzepte, API's, Konfigurationsmöglichkeiten sind einfach verständlich und sind für den Entwickler und Administrator schnell erlernbar. & 4 & Die neue Architektur besitzt als ganzes bereits eine gewisse Komplexität. Sind die neuen Teile selber komplex wird dadurch das ganze System automatich schwerer zu verstehen.\\ \hline
		BK-\arabic{bk} \stepcounter{bk} & Strategisch & Der Einsatz der Software/Plattform wurde auf Firmenebene als strategisch definiert. & 5 & Der Einsatz einer anderen Lösung ist nach wie vor gestattet muss jedoch begründet werden und fällt in die Kategorie 'Special Solutions' für welche die entsprechende Abeilung später die Kosten tragen muss.\\ \hline
		BK-\arabic{bk} \stepcounter{bk} & Know-How & Wissen was bereits über die Technologie vorhanden ist respektive wie diese eingesetzt werden kann & 2 & Obschon dadurch Kosten und Zeit gespart werden können, ist es auch ein Hinderniss bei der Suche eine passenden Lösung. Vor allem in anbetracht der Anfoderungen welche neue Denkansätze verlangt.\\ \hline
		BK-\arabic{bk} \stepcounter{bk} & Konfigurations- änderung & Massstab wie einfach es ist die Konfiguration der Applikation mit der Software zu ändern. & 5 & Nicht-funktionale Anforderung, dass gewissen Eigenschaften ohne einen neustart geändert werden könne.\\
		\bottomrule
\end{longtable}	

\end{landscape}
\restoregeometry
\newpage
Für folgende Lösungsvarianten werden zuerst kleine Prototypen gemacht um die Annahmen und Risken besser evaluieren zu können.

Datenspeicher 
MongoDB, MySQL

MySQL Prototyp mit Trigger erfolgreich. 
Mon

Konfigurationmanagement
OpenShift, Spring Cloud Config

\section{Lösungsvarianten}

Mithilfe der Teillösungen wurden folgende Lösungsvariante erstellt. 

\chapter{Installation Log}

Setup von MySQL auf OpenShift
OpenShiftClient installieren.

1. Account erstellen.
2. Projekt erstellen
3. Terminal öffnen
4. Template anlegen mit: oc create -f \url{https://raw.githubusercontent.com/sclorg/mysql-container/master/5.7/examples/replica/mysql_replica.json}

