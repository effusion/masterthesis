\newcounter{bk} \stepcounter{bk} %Bewertungskriterien counter

\chapter{Entwurfsentscheidungen}
\label{entwurfsentscheidungen}
\section{Teillösungen}

Um eine Architektur zu entwickeln, müssen zuerst Lösungen für die Teilprobleme erarbeitet werden. in den folgenden Kapiteln sind mehrere Varianten mit ihren Vor-, Nachteilen und Risiken aufgeführt. Diese Ansätze sind nur oberflächlich erforscht worden um den Lösungsraum möglichst gross zu machen. Diese Ansätze werden dann bewertet mit welchen Lösungsvarianten zusammenstellen werden. Diese Varianten wiederum gelten als Basis für die Prototypen um zu verifizieren das die wichigten Punkte eingehalten werden können. Erst danach wird die Architektur definiert.

\subsection{Schnittstellen Versionierung}

Die Versionierung der Schnittstelle zwischen der Webseite und dem Server muss sichergestellt werde. Da bei der kontinuierlichen Ausrollung von Software meistens mehrere Versionen im laufenden Betrieb sind, muss ein Weg gefunden werden dies auf einfache Weise zu erreichen ohne für den Entwickler zuviel Aufwand zu generieren.

\subsubsection{Versionierung mittels Pfad}

Sollte es nötig sein eine neue Version der \Gls{REST} Schnittstelle zu veröffentliche, kann dies über Versionsnummer im Pfad erreicht werden. Hierfür wird die URL für den Rest-Endpoint mit einer Versionsnummer versehen z.B 'servername/meon/api/v2/'.
\newline
\newline
\textbf{Vorteile}
\begin{itemize}
	\item Schnittstellenversionen sind durch den Pfad klar getrennt.
\end{itemize}
\textbf{Nachteile}
\begin{itemize}
	\item Für jede neue Version muss eine neuer Endpoint inklusive URI definiert werden welche der Client kennen muss.
	\item Domänenmodelle liegen unterumständen in mehreren Versionen vor.
	\item Verhältnismässig viel Aufwand für den Nutzen.
\end{itemize}

\subsubsection{Versionierung mittels Content-Negotiation}

Mittels Accept-Header ist es möglich auf einem Endpoint zu definieren welche Version der Resource er akzeptiert. Dadurch kann auf Rest-Controller Ebene eine Art Routing gemacht werden welche Methode die Anfrage entgegen nimmt und so die Versionierung sichergestellt werden.
\newline
\newline
\textbf{Vorteile}
\begin{itemize}
	\item Es gibt nicht mehrere Pfade nach aussen sondern nur einer.
	\item Es können auch kleinere Änderungen gemacht werden ohne die Kompatibilität zu brechen.
\end{itemize}
\textbf{Nachteile}
\begin{itemize}
	\item Auf Serverseite ist trotzdem ein Routing notwending in Form einer neuen Methode falls es sich um eine inkompatible Änderung handelt.
	\item Domänenmodelle liegen unterumständen in mehreren Versionen vor.
	\item Verhältnismässig viel Aufwand für den Nutzen.
\end{itemize}

\subsubsection{Versionierung mittels GraphQL}

Anstelle der klassischen Ansätze der Versionierung über Pfade und Content-Negotiation, gibt es mit GraphQL eine Libary welche diese Probleme anders angeht. Anstelle einer Versionierung können die Attribute mittels einer Abfragesprache vom Server angefordert werden. Dadurch benötigt es auf Serverseite nur noch einen Endpoint.
\newline
\newline
\textbf{Vorteile}
\begin{itemize}
	\item Keine wirkliche Versionierung nötig. Alte Felder können mit deprecated gekennzeichnet werden und nach der kompletten Ausrollung entfernt werden.
	\item Aufwand einiges geringer als bei der Variante mit Pfaden und Content-Negotiation.
\end{itemize}
\textbf{Nachteile}
\begin{itemize}
	\item Der Web Client braucht eine Anpassungen seiner Afrufe an den Server.
\end{itemize}
\textbf{Risiken}
\begin{itemize}
	\item Im Rahmen eines neuen Projekts wurde ein Proof of Concept gemacht allerdings sind noch keine wirklichen Erfahrungen vorhanden.
\end{itemize}

\subsection{Kommunikationsentkopplung}

Durch die geänderten Anforderungen bezüglich Ausrollung der Software ist ein unterbruch zwischen Server und der Business Process Engine unausweichlich. Damit keine Anfragen der Benutzer verloren gehen müssen die Nachrichten entweder gespeichert werden oder es brauch eine Asynchrone Kommunikation. Aktuell werden zwischen dem Server und der \Gls{BPM} Engine \gls{REST} Call mittels Hystrix abgesetzt.

\subsubsection{Message Queue mit JMS}

Entkopplung kann generell über Messaging erreicht werden welches in der Java Welt mittels dem Java Messaging Service erreicht werden kann. Da an den Benutzer keine Anwort geschickt werden muss, braucht es nicht unbedingt eine Antwort. Die Zustellung der Nachricht muss jedoch sichergestellt werden. Des Weiteren müssen die Nachrichten dürfen die Nachrichten bei einem Kommunikationsunterbruch nicht verloren gehen.
\newline
\newline
\textbf{Vorteile}
\begin{itemize}
	\item Gute Unterstützung durch das Spring Framework.
	\item Bekanntes Integrationsmuster.
	\item Inhalt der Nachrichten frei wählbar.
\end{itemize}
\textbf{Nachteile}
\begin{itemize}
	\item Umbau der Schnittstelle zwischen Server und BPM Engine.
	\item Messaging Infrastruktur ist nicht vorhanden respektive nicht Verfügbar in der Zone. Diese wäre zusätzlich ein weitere Single Point of Failure.
	\item Messaging Infrastruktur ist für den Use Case überdimensioniert.
\end{itemize}
\textbf{Risiken}
\begin{itemize}
	\item Nicht sicher ob eine solche Middleware überhaupt verwendet werden darf respektive ob Know-how vorhanden ist.
\end{itemize}

Alternative könnte anstelle eine Messaging System auch eine Message Bridge verwendet werden. Hierzu verbindet sich der Server direkt auf die Queue welche sich auf der BPM Engine befindet.

\subsubsection{Message Queue mit Kafka}

Eine weitere Möglichkeit wäre das Versenden von Nachrichten über Kafka\footnote{https://kafka.apache.org}. Entstanden bei grossen Internet Dienstleistern wie Linkedin für welche JMS nicht praktikabel war Aufgrund der Perfomanz(verifizieren). Kafka ist ein verteiltes Messaging System welches auf durchsatz optimiert ist. Für die Zustellung der Nachrichten verwendet Kafka einen sogenannten Nimbus welche die Zustellung an den Empfänger übernimmt.
\newline
\newline
\textbf{Vorteile}
\begin{itemize}
	\item Unterstützung durch das Spring Framework.
	\item Bekanntes Integrationsmuster.
	\item Inhalt der Nachrichten frei wählbar.
	\item Braucht keine zentrale Infrastruktur und kann selber aufgebaut werden.
\end{itemize}
\textbf{Nachteile}
\begin{itemize}
	\item Umbau der Schnittstelle zwischen Server und BPM Engine.
	\item Infrastruktur muss selber administriert werden.
	\item Für den Use Case überdimensioniert da gar nie soviele Nachrichten über das System verschickt werden.
\end{itemize}
\textbf{Risiken}
\begin{itemize}
	\item Know-how zu Kafka hinsichlicht Betrieb und Verwendung nicht vorhanden.
\end{itemize}

\subsubsection{Message Queue mit Key-Value Store}

Anstelle eines Messaging Systems, bietet sich die Möglichkeit an Redis als Message queue zu verwenden. Würde Redis gleichzeitig als Datenspeicher verwendet könnten hier Synergien genutz werden. 
\newline
\newline
\textbf{Vorteile}
\begin{itemize}
	\item Bietet asynchrones Messaging über eine eingebaute Queue Funktionalität.
	\item Schemalos und wodurch Nachrichten eifach gespeichert werden können.
	\item Eliminiert die Probleme der Speicherung und Asynchronität gleichzeitig.
\end{itemize}
\textbf{Nachteile}
\begin{itemize}
	\item Umbau der Schnittstelle zwischen Server und BPM Engine.
\end{itemize}
\textbf{Risiken}
\begin{itemize}
	\item Java Connection für Master/Slave Konfiguration befindet sich noch in der Entwicklung resp. muss selber gemacht werden. Gleiches gilt für die Clusterfunktionalität.
\end{itemize}

\subsubsection{Spring Rest}

Aktuell werden die Requests an die BPM Engine mittels Hystrix\footnote{https://github.com/Netflix/Hystrix} und \gls{REST} abgeschickt. Die Request werden dabei gleich zur Workflow Engine geschickt oder im Fehlerfall als JSON in die Datenbank gespeichert. Mit einem Scheduler werden dann später die nicht gesendeten Request nochmals verschickt. Die Datenbank hat deshalb eine Queue ähnliche Funktion.
\newline
\newline
\textbf{Vorteile}
\begin{itemize}
	\item Nur geringfügige Anpassungen an der Schnittstelle auf Serverseite.
\end{itemize}
\textbf{Nachteile}
\begin{itemize}
	\item Keine wirkliche Entkopplung der Dienste.
\end{itemize}
\textbf{Risiken}

\subsection{Datenspeicherung}
\label{ent-db}
Aktuell wir eine MySQL als Datenbank verwendet welche zur Zeit nur Requests speichert und kleinere Abfragen ausführt.. Die neuen Anforderungen an die Datenbank bezüglich Continuous Deployment sind:
\begin{itemize}
	\item Replikation wird unterstützt und kann auf dem Client konfiguriert werden.
	\item Es ist möglich mit mehreren Applikations Version auf die gleiche Datenbank zuzugreifen.
\end{itemize}
Vorallem der Zweite Punkt hat hohe bedeutung da bei Continuous Delivery bei der Installation der Software immer mindest zwei verschiedene Versionen der Applikation gleichzeitig auf den Datenspeicher zugreifen. Die Anwendung verwendet bereits Spring Data als Persitzenz-Bibliothek welche für alle aufgeführten Lösungsvarianten entsprechende Erweiterungen besitzt. Der Serverteil hält aktuell nur sechs Tabellen da die ganze Verarbeitung der Daten auf der Workflow-Engine gemacht wird.

\subsubsection{Relationale Datenbank mit Oracle}

Oracle ist bei vielen Firmen die Standart Software für Datenbank. Sie bietet sämtliche Features welche im Bereich von Finanzdienstleistern benötigt werden hat aber auch ihren Preis. Oralce basiert auf klassischen relationalen Prinzipien und setzt auf hohe Datenkonsitzenz. Für die Replikation bietet Oracle diverse Mechanismen und Setup welche unterschiedliche Kosten haben.
\newline
\newline
\textbf{Vorteile}
\begin{itemize}
	\item Sehr gutes und verbreitetes Know-how bezüglich Betrieb, erstellen von Anfragen, optimierung usw.
	\item Baisert auf \Gls{ACID} und gewährteistet deshalb die Datenkonsistenz.
	\item Bietet Enterprise fähige Replikationsmechanismen.
\end{itemize}
\textbf{Nachteile}
\begin{itemize}
	\item Daten werden nach einem Schema abgelegt welches nicht mit verschiedenen Versionen umgehen kann.
	\item Versionierung muss selber mittels Triggern und Migrationsskripten gemacht werden.	
	\item Für die aktuell sechs Tabellen ein grosser Kostenpunkt. 
\end{itemize}
\textbf{Risiken}
\begin{itemize}
	\item Oracle darf aus Lizenzgründen nur auf pysischen Maschinen installiert werden.
	\item High Availability Mode welcher zu Verfügung steht nicht klar.
\end{itemize}

\subsubsection{Relationale Datenbank mit MySQL}

MySQL wird wie bereits aktuell verwendet. Es bietet die klassischen Funktionen einer relationalen Datenbank. MySQL wird meistens verwendet wenn Oracle zu teuer ist resp. die Anforderungen an die Datenhaltung nicht so hoch sind. MySQL bietet akutell auch Replikation mittels Master-Slave an und Tools für eine automatische Umschaltung
\newline
\newline
\textbf{Vorteile}
\begin{itemize}
	\item Wird bereits eingesetzt.
	\item Baisert auf \gls{ACID} und gewährteistet deshalb die Datenkonsistenz.
\end{itemize}
\textbf{Nachteile}
\begin{itemize}
	\item Daten werden nach einem Schema abgelegt welches nicht mit verschiedenen Versionen umgehen kann.
	\item Versionierung muss selber mittels Triggern und Migrationsskripten gemacht werden.
\end{itemize}
\textbf{Risiken}
\begin{itemize}
	\item Kein Know-How mit MySQL Cluster oder dem Mysqlfailover Util.
\end{itemize}

\subsubsection{Dokumentenbasierte Datenbank}

Als alternative zu einer relationalen Datenbank, kann eine dokumentenbasierte wie zum Beispiel MongoDB\footnote{https://www.mongodb.com} verwendet werden. Die Datenbank gehöhrt zu Familie der \Gls{NoSQL} Speicher und ist deshalb Schemalos. Von den \gls{NoSQL} Datenbanken besitzen die Dokumente basierte die grösste Struktur im sinn der Datenspeicherung.
\newline
\newline
\textbf{Vorteile}
\begin{itemize}
	\item Kein Schema vorhanden weshalb die Daten in verschiedenen Versionen gespeichert werden können.
	\item Hirarchische struktur von JSON passt gut zur Natur der Datenbank.
	\item Bietet Datenreplikation mittels Master/Slave und Replica Sets.
\end{itemize}
\textbf{Nachteile}
\begin{itemize}
	\item Anpassung des Persistzenslayers nötig.
\end{itemize}
\textbf{Risiken}
\begin{itemize}
	\item Keine Erfahrung mit der Datenbank (Verwendung, Betrieb, Abfragen).
\end{itemize}

\subsubsection{Key-Value Datenbank}

Eine weitere Möglichkeit ist ein Key-Value Store für die Speicherung zu verwendent. Es handelt sich Dabei um eine \gls{NoSQL} Datenbank welche wie eine HashMap Funktioniert. Daten können schnell gespeichert und mit dem Key wieder geholt werden. Gewisse Abfrage Möglichkeiten sind ebenfalls gegeben. Des Weiteren ist die Datenbank Schema was eslaubt verschiedenste Strukturen zu speichern. In diesem konkreten Fall wird Redis\footnote{https://redis.io} als Lösung in betracht gezogen. \newline
\newline
\textbf{Vorteile}
\begin{itemize}
	\item Bereits in Betrieb und daher vorhandenes Know-how
	\item Kein Schema vorhanden weshalb die Daten in verschiedenen Versionen gespeichert werden können.
	\item Bietet High Availablity wie Clustering und Sentinel.
	\item Könnte im gleichen Zuge auf für die Queue verwendet werden.	
\end{itemize}
\textbf{Nachteile}
\begin{itemize}
	\item Abfrage Möglichkeiten beschränkt.
	\item Anpassung des Persistzenslayers nötig.
\end{itemize}
\textbf{Risiken}
\begin{itemize}
	\item Keine Erfahrung mit den Clusterfuntkionalitäten.
\end{itemize}

\subsection{Konfigurations Management}

Soll die Applikation kontinuierlich ausgerollt werden, sind manuelle Anpassungen an Konfigurationsdateinen hinderlich. Ob das nun Propert files, Dockerfiles oder andere Dateinen sind. Gewisse Änderungen erfordern einen neustart von Systemen falls für den Container eine neue Version gebaut wird. Für andere wäre es wünscheswert gäbe es einen Weg die Konfiguration ohne einen anzupassen. Hierzu einige Beispiele:\newline
\begin{itemize}
	\item Hostnamen, Ports
	\item Usernamem, Passwörter, Email-Adressen
	\item Datenbank Konfigurationen
	\item Dateien welche Zertifikate beinhalten.
\end{itemize}

Auf Testumgebungen ist dies meistens kein Problem da entsprechene Konfigurationen mitabgelegt sind. Die Probleme treten aktuell hauptsächlich für Produktive Systeme bei welchen keine Passwörter mit eingegeckt werden können.

\subsubsection{Docker Compose, Swarm}

Aktuell ist die Konfiguration der Container in einem Properties gespeichert. Mit Compose\footnote{https://docs.docker.com/compose/} werden die Anhängigkeiten zwischen den Container definiert und die Konfiguration in den Container gelinkt.\newline
\newline
\textbf{Vorteile}
\begin{itemize}
	\item Wird aktuell bereits eingesetzt.
	\item Konfigurationen der Container können von aussen injziert werden.
\end{itemize}
\textbf{Nachteile}
\begin{itemize}
	\item Konfigurationsänderungen an der Applikation führen zu einem neustart.
\end{itemize}
\textbf{Risiken}
\begin{itemize}
	\item Nicht kombatibel mit Kubernetes welche bei Openshift\footnote{https://www.openshift.org: Plattform welche das Ausrollen von Containers im Sinne einer Cloud Umgebung ermöglicht.}  verwendet wird. Die Plattfrom ist im Aufbau und wird die zukünfige Plattform.
\end{itemize}

\subsubsection{Kubernetes}

Kubernetes ist ein andere Framework\footnote{http://kubernetes.io: Wurde von Google Entwickelt und beschränkt sich nicht nur auf Docker Container.} für die Konfiguration von Containern und deren Abhängigkeiten. Kubernetes verfolgt eine andere Philosophie und ist aus diesem Grund nicht kompatible mit der Docker eingenen API.
\newline
\newline
\textbf{Vorteile}
\begin{itemize}
	\item Ist die Basis von Openshift welches als Standart Plattform für Container etabliert werden soll und daher von strategische Bedeutung.
\end{itemize}
\textbf{Nachteile}
\begin{itemize}
	\item Anpassungen an der Orchestration der Container.
\end{itemize}
\textbf{Risiken}
\begin{itemize}
	\item Plattform ist noch nicht wirklich in Betrieb sonder nur zu Testzwecken installiert.
	\item Kein Know-how zu Kubernetes vorhanden.
\end{itemize}

\subsubsection{Spring Cloud Config}

Spring Cloud Config\footnote{https://cloud.spring.io/spring-cloud-config/} bieted die Möglichkeit Konfigurationen währed dem laufend Betrieb zu ändern. Dadurch muss ein Applikation/Container bei Konfigurationänderungen nicht neu gestartet werden. Änderungen am Deployment des Containers selber kann die Library jedoch nicht ändern.\newline
\newline
\textbf{Vorteile}
\begin{itemize}
	\item Integriert sich gut mit dem Spring Framework
	\item Konfigurationen können während dem laufenden Betreib geändert werden.
	\item Da der Server zustandslos ist, kann Hochverfügbarkeit einfach erreicht weden.
\end{itemize}
\textbf{Nachteile}
\begin{itemize}
	\item Benötigt einen neuen Config Server und Anpassungen der Applikation.
	\item Kann keine Änderungen an der Containerkonfiguration vornehmen.
\end{itemize}
\textbf{Risiken}
\begin{itemize}
	\item Erhöht die Komplexität des Systems weiter.
\end{itemize}

\subsubsection{Saltstack}

Saltstack ist ein Konfigurationmanagement mit welchem sich Server und deren Applikationen auf verschiedenen physischen oder virutell Rechner konfigurieren lassen. Zusätzlich können die Server gruppiert werden um logische Einheiten wie Entwicklung, Test, Produktion zu modellieren.\newline
\newline
\textbf{Vorteile}
\begin{itemize}
	\item Erlaub das Schreiben von Konfugrationsscripty mittels Python.
	\item Benötigt kein grosses Setup auf dem Client.
\end{itemize}
\textbf{Nachteile}
\begin{itemize}
	\item Kolidiert mit dem Ansatz Containern da diese unveränderbar sind und Änderungen deshalb von aussen injziert werden müssen.
	\item Kein Know-how vorhanden.
\end{itemize}
\textbf{Risiken}
\begin{itemize}
	\item Wird durch den Einsatz von OpenShift für Container wahrscheinlich obsolet.
\end{itemize}

\section{Bewertungskriterienkatalog}

Mit Hilfe der Bewertungskriteren sollen die einzelne Teillösungen bewertet werden um daraus Lösungsvarianten zu definieren. Für die Varianten oder Teillösungen werden dann Prototypen entwickelt um deren Umsetzbarkeit zu verfizieren. Die Bewertungskriterien mögen sich stellenweise mit den Qualitätszielen überschneiden, betrachten die Lösungen jedoch auf einen anderen Ebene. Nicht alle Kriterien sind auf alle Teillösungen anwendbar und werden in der Matrix später nicht ausgefüllt.\newline
Für die Gewichtung als auch die für die Bewertung wird eine Skala von Eins bis Fünf verwendet mit Eins als schwache Gewichtung/Bewertung und Fünf als starte Gewichtung/Bewertung.

\newgeometry{left=2.5cm, right=2.5cm, bottom=2.5cm, top=2.5cm}
\begin{landscape}
\begin{longtable}{ | p{1.2cm} | p{3cm} | p{8cm} | p{2cm} | p{8cm} | }
		\toprule
		{\textbf{ID}} & {\textbf{Name}} & {\textbf{Beschreibung}} & {\textbf{Gewicht}} & {\textbf{Begründung}}\\
		\midrule 
		BK-\arabic{bk} \stepcounter{bk} & Ausfallsicherheit / Konsistenz & Die Komponente ermöglicht automatische Ausfallsicherheit ohne manuelle interaktion eines Administrators.& 5 & Nicht-funktionale Anforderung an die Architektur. Notwending dabei bei kontinuierlicher Ausrollung keine inkonsistenzen entstehen.\\ \hline
		BK-\arabic{bk} \stepcounter{bk} & Reifegrad & Die Komponente wird akutell von anderen Firmen in produktiven Umgebungen eingesetzt und hat eine ausführliche Dokumentation und Literatur. Für Obensource gilt, dass die Komponente eine entsprechende Community hat und aktive entwickelt wird.  & 4 & Der Einsatz von unreifer Software führt zu Mehraufwand in Fehlerfällen resp. falls Fehler auftreten die lange brauchen bis sie behoben werden.\\ \hline
		BK-\arabic{bk} \stepcounter{bk} & Entkopplungsgrad & Die Komponente erlaubt die asynchrone Kommunikation.& 4 & Nicht-funkionale Anforderung welche wichtig ist damit der Benutzer von einem unterbruch des Dienstes nichts merkt. \\ \hline
		BK-\arabic{bk} \stepcounter{bk} & Skalierbarkeit & Die Komponente lässt sich durch Konfiguration resp. durch bereitstellen eines neuen Containers horizontal skalieren.& 5 & Nicht-funktionale Anforderungan die Architektur. Während der Installation ist immer ein Teil der Applikation nicht erreichbar. Die Skalierbarkeit stellt deshalb sicher, dass in diesem Fall immer genug Resourcen vorhanden sind um die Anfragen zu bearbeiten. \\ \hline
		BK-\arabic{bk} \stepcounter{bk} & Wartbarkeit & Die eingesetzte Komponente ist Wartungsfreundlich und braucht. & 3 & Die Wartung der Software sollte in einem angemessenem Rahmen möglich sein.\\ \hline
		BK-\arabic{bk} \stepcounter{bk} & Lizenzkosten & Die Komponente hat möglichst kleine einmalig und wiederkehrende Kosten. & 3 & Die Kosten sind wichtig jedoch ist im Bereich der Finanzindustrie die Konsistenz höher weit gewichtet.\\ \hline
		BK-\arabic{bk} \stepcounter{bk} & Testbarkeit & Die Komponente läst sich einfach in einer Testumgebung oder für Unittests aufsetzten. &  3 & Die Komponente sollte sich gut testen lassen. Das ein gewisser Aufwand wird jedoch in kauf genommen.\\ \hline
		BK-\arabic{bk} \stepcounter{bk} & Interportabilität & Die Komponente ist technologisch Unabhängig und lässt sich einfach mit anderen integrieren. & 3 & Die Software sollte sich mit den wichtigsten Technologien verwenden lassen. Die Applikation selber ist jedoch spezifsch weshalb dies weniger gewertet wird.\\ \hline
		BK-\arabic{bk} \stepcounter{bk} & Lernkurve & Die Konzepte, API's, Konfigurationsmöglichkeiten sind einfach verständlich und sind für den Entwickler und Administrator schnell erlernbar. & 4 & Die neue Architektur besitzt als ganzes bereits eine gewisse Komplexität. Sind die neuen Teile selber komplex wird dadurch das ganze System automatich schwerer zu verstehen.\\ \hline
		BK-\arabic{bk} \stepcounter{bk} & Strategisch & Der Einsatz der Software/Plattform wurde auf Firmenebene als strategisch definiert. & 5 & Der Einsatz einer anderen Lösung ist nach wie vor gestattet muss jedoch begründet werden und fällt in die Kategorie 'Special Solutions' für welche die entsprechende Abeilung später die Kosten tragen muss.\\ \hline
		BK-\arabic{bk} \stepcounter{bk} & Know-How & Wissen was bereits über die Technologie vorhanden ist respektive wie diese eingesetzt werden kann & 2 & Obschon dadurch Kosten und Zeit gespart werden können, ist es auch ein Hinderniss bei der Suche eine passenden Lösung. Vor allem in anbetracht der Anfoderungen welche neue Denkansätze verlangt.\\ \hline
		BK-\arabic{bk} \stepcounter{bk} & Konfigurations- änderung & Massstab wie einfach es ist die Konfiguration der Applikation mit der Software zu ändern. & 5 & Nicht-funktionale Anforderung, dass gewissen Eigenschaften ohne einen neustart geändert werden können.\\ \hline
		BK-\arabic{bk} \stepcounter{bk} & Multi Version & Wie einfach kann die Datenbank mit mehrere Version umgehen und wie einfach sind die Konzepte dafür diese umzusetzen. & 5 & Die Umsetzung von Continuous Deployment ein sehr centraler Punkt da die Applikation zu jederzeit mit mehreren Version auskommen muss.\\ \hline
		BK-\arabic{bk} \stepcounter{bk} & Anpassungen & Gewisse Codeteile müssen unweigerlich Angepasst werden und versuchen daher Aufwand. Hier sind vorallem Schnittsellen und die Persistenz betroffen. & 3 & Für die Erfüllung der Ziele kann dies in kauf genommen werden solang der Aufwand nicht zu hoch wird.\\
		\bottomrule
\end{longtable}	

\end{landscape}
\restoregeometry
\newpage

\section{Bewertungen}

Die Ausgefüllte Bewertungsmatrix findet sich im Anhang des Dokuments. Folgend die Begründungen für die einzelnen Bewertungen und deren Schlussfolgerungen

\subsection{Schnittstellen Versionierung}


\subsection{Kommunikationsentkopplung}

Die Messaging basierten Variante für Entkopplung haben sich für den Use Case als nicht passend respektive als zu überdimensioniert erwiesen. Die SIX hat eine Messaging Infrastruktur(JMS) welche allerdings nicht unter der Kontrolle des Projektes ist und zur kritischen Infrastruktur gehört. Aus diesem Grund ist dies keine Option. Kafka und Redis können ebenfalls als Message Queue verwendet werden. Bei diesen beiden Varianten würde man die Komponenten selber administrieren und hätte dadurch eine grössere Kontrolle. Bei Redis ziehen die gleichen Arguemten wie schon beim Datenspeicher weshalb die Variante nicht inbetracht gezogen wird. Bei Kafka gelten die gleichen Überlegungen wobei noch hinzukommt, dass die Plattform nicht dem Zweck entspricht da sie für Hochverfügbare Message Systeme mit sehr hohe Durchsatz konzipiert ist.\newline
Schlussendlich wird die aktuelle Lösung mittels Spring REST weiterverwendet und im Fall eines Fehler, die Nachricht in die Datenbank gespeichert damit sie nicht verloren geht. Aktuell ist die Workflow Engine noch nicht hochverfügbar die Hersteller haben solche Konzepte für die neuen Versionen schon implementiert. Daher ist die Notwendigkeit einer asynchronen Kommunikation nicht mehr vorhanden.

\subsection{Datenspeicherung}

Für die Datenspeicherung standen Oracle, Mysql, MongoDB und Redis zu Auswahl(Siehe Kapitel \ref{ent-db}). \newline
Oracle hat die höchste Bewertung erhalten da die Firma mit dieser Datenbank schon viele Jahre Erfahrung hat und dementsprechen die relationalen Konzepte bestens versteht. Auf Grund von Lizenzbestimmungen seitens Oracles hat SIX keine Lizenzen welche es erlaubt Oracle Instanzen auf einer virtualisierten Umgebung zu installieren. Oracle kann deshalb nicht als Datenspeicher berücksichtigt werden.\newline
Redis ist wird teils in der Firma schon verwendet, jedoch ist die Datenbank nicht wirklich passend für den Usecase und die Lernkurve um alles nur in einer Map zu speichern macht die Datenbank zu am wenigsten passenden Option. Auch deshalb da für die Datenbank nur der Support der Community verfügbat ist.\newline
MySQL erhielt die zweitbeste Bewertung und liegt vor MongoDB. Obschon die relationalen Konzepte besser bekannt, wurde entschieden für beide einen Prototypen zu machen um den Umgang mit mehrere Schemaversionen zu evaluieren da. Für MongoDB müssen noch Themen wie Replikation und der Aufwand für die Umstellung der Repositories berrücksichtigt werden.

\subsection{Konfigurationsmanagement}

Applikationen welche kontinuierlich ausgerollt werden sollen, brauch zwingend eine Art Konfigurationmanagement um Tätigkeiten wie Installationen und Aktualisierungen zu automatisieren. Die aktuelle Lösung mittels Docker und Docker Compose erlaubt zwar die Verwendung von Container und somit eine einfache Kapeslung wurde jedoch von den Entwicklern für produktive Umgebungen als schwer wartbar bezeichnet. Der Reifegrad ist trotz der schnellen Entwicklung vor allem bei den Orchestrierungsmechanismen noch nicht wirklich gegeben.\newline
Saltstack als welches schon produktive eingesetzt bietet durch seine Verbreitung viele Vorteile. In Kombination mit Containern fehlt allerdings die Orchestrierungsmöglichkeit um mehrere miteinander zu verbinden. Für die Applikation direkt macht Saltstack trotz der hohen Bewertung daher keinen Sinn.\newline
OpenShift als Plattform wird von der SIX als strategisch angesehen und hat damit das Ziel später einen grossteil der Applikation darauf zu migrieren. Aktuell gibt es Testinstanzen auf Grund von Compliance Anforderungen ist das ganze Deployment der Plattform noch nicht komplett definiert. Falls Projekte die Plattform nicht nutzen, fallen sie unter den Bereich 'Spezial Solutions' was zu Folge hat, dass die Kosten für den Betrieb von der Abteilung bewältigt werden muss. Daher ist OpenShift für das Deployment der Container die einzige Wahl.
Spring Cloud Config wird als Ergänzung zu OpenShift verwendet wo Applikationsspezifische Konfigurationen zu laufzeit geändert werden müssen. Obschon diese mittels eines neustart des Containers möglicht ist, kann so ein unterbruchsfreie Betrieb gewährleistet werden.

\subsection{Deployment Pipeline}

\section{Prototypen}

Folgend die Prototypen welche erstellt wurden um die Risiken und Unsicherheiten bei der Lösungsvarianten zu bestätigen oder zu wiederlegen. 

\subsection{MySQL, MongoDB Schema Migration}

Um die Möglichkeiten einer Schema Migration ohne unterbruch zu evaluieren,wurden folgende zwei Use Cases ausgewählt:
\newline
\begin{itemize}
	\item Änderung einer Spalte
	\item 'Split Table' bei welcher eine Tabelle in mehrere aufgeteilt werden.
\end{itemize}

Für beide Datenbanktypen ist einer Migration zweistufig da gleichzeitig mehrere Versionen der Applikationen auf die Datenbank zugreifen. Bei MySQL werden dabei Trigger verwendet welche die Daten zwischen den Kolumen respektive den Tabellen hin und her schieben. Sind mehrere Tabellen involviert, muss auf zirkuläre Trigger geachtet werden. Für die meisten Probleme gibt es Lösungen im Buch Database Refactoring \footnote{Database Refactoring: Evolutionary Database Design: Addison Wesley Signature Series: Scott J Ambler, Pramod J Sadalage: 2006}. Sobald alle Versionen der Applikation angehoben sind, können die Trigger und entsprechenden obsolete Columen gelöscht werden. Der Entwickler sich bei einer Änderung um die entsprechenden Scripts kümmern und diese auch testen.\newline
Im gegensatz zu MySQL ist bei MongoDB keine Migrationsskript beim ausrollen der neuen Version von Nöten. Die Datenbank kann mit mehreren Dokumentversionen gleichzeitig umgehen. Anstelle von Triggern muss die Migration im Code gemacht werden. Für den Entwickler bedeutet das nicht weniger Aufwand der Ort ist schlicht ein anderer. Ein Vorteil ist, dass die Daten über Zeit migriert werden können und zu einem spätere Zeitpunkt die verbleibenden Daten nach gezogen werden können.\newline
Beide Varianten bieten entsprechende Möglichkeiten dem Problem zu begegnen.
 

\subsection{MySQL, MongoDB Replikation}

Um Continuouse Delivery zu erreichen, müssen die Datenspeicher entsprechend hochverfügbar ausgelegt werden. MySQL als klassische \Gls{RDBMS} Datenbank bieten Replikation von Haus aus an. Gleiches gilt für MongoDB. Bei beiden kann ebenfalls der Grad er Replikation stuckweit definiert werden. Die Daten werden bei beiden Datenbanken in der Standarteinstellung asynchron repliziert. Dies wird vor allem aus Performanzgründen gemacht da Two-Phase Commits\Gls{2PC} über mehrere Standorte die Performaz eines System stark beinflussen kann. Es gibt dennoch bei beiden Datenbanken die Möglichkeit das Schreiben auf einen Slave zu verlagen. Unter MySQL heisst das Semisynchron, bei MongoDB geht das unter dem Namen WriteConcerns. Gemäss CAP-Theorem\Gls{CAP} ist MySQL als konsistent und verfügbar deklariert und MongoDB als konsistent und partitions tolerant. Die Replikation kann daher Produktabhängig gewährleistet werden wobi MongoDB durch die Architektur besser geeignet ist da der Handover zwischen den Servern voll automatisch geschiet und nicht ein Umschaltung gemacht werden muss.

\subsection{Graphql}

GraphQL ist eine Technologie welche von Facebook entwickelt wurde um den Umgang mit mehreren Schnittstellen Versionen für die verschiedenen Endgeräte besser umgehen zu können. Dabei wird eine Art Abfrage an den \gls{REST} Endpunkt gesendet welcher anschliessend die Daten dynamisch sammelt und an den Client sendet. Um die Funktionsweise der Bibiliothek besser einschätzen zu können, wurde ein einfacher Prototyp gemacht welche die Use Cases von Lesen und Schreiben abbildet.\newline
Der Prototyp konnte erfolgreich umgesetzt werden hat jedoch einige negative Erkenntnisse über die Bibliothek zu gezeigt. Folgend eine Auflistung der Probleme:\newline
\newline
\begin{itemize}
	\item Model für das Schreiben und Lesen müssen separat definiert werden was faktisch zum doppelten Code fürt.
	\item Viele Einstellungen müssen mit Stringvariablen angegeben werden und ist deshalb fehleranfällig.
	\item Für Mutationen müssen die Variable aus einem untypisieren hirarchischen Arguemten herausgeparst werden was unter statisch typisierten Sprachen wie Java zu sehr viel Konvertierungscode führt.
\end{itemize}
Die Library wurde von Facebook für dynamische Sprachen entwickelt und ist für diese Verwendung sicher besser geeignet. Die Library wurde von Entwicklern nach Java protiert und wird auf GitHub gehostet. Der Zustand der Library ist nur anhand von GitHub schwer zu evaluieren und brigt das Risiko, dass im Fall von Probleme keine Fehler behoben werden oder dies schlussendlich selber gemacht werden muss.

\subsection{Spring Cloud Config}

Spring Cloud Config erlaubt es, Änderungen an der Konfiguration der Applikation zu Lauftzeit durchzuführen. Auf der Clientseite werden Klassen welche Properties haben entsprechend annotiert und beim Start der Applikationoder wenn die entsprechende URL aufgerufen wird, aktualisiert. Der Server überprüft dabei regelmässig das git Repository auf Änderungen und kann wahlweise auf mittels eines Hook auf dem Repositoryserver angestossen werden. Für kleinere Applikationen mag das ausführen einer URL noch praktikabel sein, für grössere Deployments ist dies hingegen sehr umständlich. Deshalb kann durch hinzufügen von Spring Cloud Bus und einer Messagequeue wie RabbitMQ, dieser Prozess vereifacht werden. Die Clients und der Server verbinden sich auf den entsprechenden Message Server und erhalten bei einer Konfigurationänderung eine Nachricht die entsprechenden Properties zu aktualisieren.

\subsection{OpenShift}

OpenShift ist eine Plattform as a Service Lösung welche es erlaubt Docker Container zu Orchestrieren und somit ganze Umgebungen aufzubauen. Das Produkt basiert in der neuen Version auf Kubernetes und fügt über die Konsole respektive die Benutzeroberfläche gewisse Administrationsfunktionen hinzu. 

\section{Entscheidungen}

Nach den 